// scripts/delete-sports-markets.js
// Removes all auto-generated sports markets (seeded via seed-sports-markets.js).
//
// Targets markets with autoGenerated == true (ESPN-seeded game markets).
// Manually-created sports markets are NOT affected.
//
// For OPEN / LOCKED markets: refunds users' net invested amounts first.
// For CANCELLED markets:     already refunded â€” deletes market + bets.
// For RESOLVED markets:      payouts already settled â€” deletes market doc only.
//
// Run with: node scripts/delete-sports-markets.js [--dry-run]

const admin = require('firebase-admin');
const serviceAccount = require('../serviceAccountKey.json');

admin.initializeApp({ credential: admin.credential.cert(serviceAccount) });
const db = admin.firestore();

const isDryRun = process.argv.includes('--dry-run');

// â”€â”€â”€ Refund logic (mirrors utils/refunds.js) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function round2(num) {
  return Math.round((Number(num) + Number.EPSILON) * 100) / 100;
}

function calculateRefundsByUser(bets) {
  const netByUser = {};
  bets.forEach((bet) => {
    if (!bet?.userId) return;
    const amount = Number(bet.amount || 0);
    if (!netByUser[bet.userId]) netByUser[bet.userId] = 0;
    netByUser[bet.userId] = round2(netByUser[bet.userId] + amount);
  });
  const refunds = {};
  Object.entries(netByUser).forEach(([userId, net]) => {
    if (net > 0) refunds[userId] = round2(net);
  });
  return refunds;
}

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function chunkArray(items, size) {
  const chunks = [];
  for (let i = 0; i < items.length; i += size) chunks.push(items.slice(i, i + size));
  return chunks;
}

async function commitBatches(ops) {
  for (const chunk of chunkArray(ops, 400)) {
    const batch = db.batch();
    for (const fn of chunk) fn(batch);
    await batch.commit();
  }
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function deleteSportsMarkets() {
  console.log(`\nðŸ—‘ï¸  Delete auto-generated sports markets${isDryRun ? ' (DRY RUN)' : ''}\n`);

  // 1. Fetch all auto-generated markets
  const snap = await db.collection('markets').where('autoGenerated', '==', true).get();
  const markets = snap.docs.map((d) => ({ id: d.id, ref: d.ref, ...d.data() }));

  if (markets.length === 0) {
    console.log('No auto-generated markets found. Nothing to do.');
    return;
  }

  const byStatus = { OPEN: [], LOCKED: [], CANCELLED: [], RESOLVED: [], OTHER: [] };
  for (const m of markets) {
    const s = m.status || 'OTHER';
    (byStatus[s] || byStatus.OTHER).push(m);
  }

  console.log(`Found ${markets.length} auto-generated markets:`);
  console.log(`  OPEN:      ${byStatus.OPEN.length}`);
  console.log(`  LOCKED:    ${byStatus.LOCKED.length}`);
  console.log(`  CANCELLED: ${byStatus.CANCELLED.length}`);
  console.log(`  RESOLVED:  ${byStatus.RESOLVED.length}`);
  if (byStatus.OTHER.length) console.log(`  OTHER:     ${byStatus.OTHER.length}`);
  console.log('');

  // Print list for review
  for (const m of markets) {
    console.log(`  [${m.status || '?'}] ${m.question}`);
  }
  console.log('');

  if (isDryRun) {
    console.log('DRY RUN â€” no changes made.');
    return;
  }

  // â”€â”€ Step 2: Refund users for OPEN / LOCKED markets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const needRefund = [...byStatus.OPEN, ...byStatus.LOCKED, ...(byStatus.OTHER || [])];

  let totalRefunded = 0;
  if (needRefund.length > 0) {
    console.log(`Processing refunds for ${needRefund.length} open/locked markets...`);

    for (const market of needRefund) {
      const betsSnap = await db.collection('bets')
        .where('marketId', '==', market.id)
        .get();
      const bets = betsSnap.docs.map((d) => d.data());

      if (bets.length === 0) {
        // No bets â€” just mark cancelled
        await market.ref.update({
          status: 'CANCELLED',
          cancelledAt: new Date(),
          cancelReason: 'Removed: auto-generated sports market cleanup'
        });
        continue;
      }

      const refunds = calculateRefundsByUser(bets);
      const userIds = Object.keys(refunds);

      const refundOps = [];

      // Update users' weeklyRep
      for (const userId of userIds) {
        const userRef = db.collection('users').doc(userId);
        const userSnap = await userRef.get();
        if (!userSnap.exists()) continue;
        const current = Number(userSnap.data().weeklyRep || 0);
        refundOps.push((batch) => {
          batch.update(userRef, { weeklyRep: round2(current + refunds[userId]) });
        });
        totalRefunded += refunds[userId];
      }

      // Mark market as cancelled
      refundOps.push((batch) => {
        batch.update(market.ref, {
          status: 'CANCELLED',
          cancelledAt: new Date(),
          cancelReason: 'Removed: auto-generated sports market cleanup'
        });
      });

      await commitBatches(refundOps);
      console.log(`  âœ“ Refunded ${userIds.length} users for: ${market.question}`);
    }

    console.log(`\nTotal refunded: $${round2(totalRefunded).toFixed(2)}\n`);
  }

  // â”€â”€ Step 3: Delete all auto-generated markets and their bets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  console.log('Deleting market documents and associated bets...');

  let deletedMarkets = 0;
  let deletedBets = 0;

  for (const market of markets) {
    const deleteOps = [];

    // For non-resolved markets, delete associated bets too
    if (market.status !== 'RESOLVED') {
      const betsSnap = await db.collection('bets')
        .where('marketId', '==', market.id)
        .get();
      for (const betDoc of betsSnap.docs) {
        deleteOps.push((batch) => batch.delete(betDoc.ref));
        deletedBets++;
      }
    }

    deleteOps.push((batch) => batch.delete(market.ref));
    deletedMarkets++;

    await commitBatches(deleteOps);
  }

  console.log(`\nâœ… Done.`);
  console.log(`   Markets deleted: ${deletedMarkets}`);
  console.log(`   Bets deleted:    ${deletedBets}`);
  if (totalRefunded > 0) {
    console.log(`   Refunded:        $${round2(totalRefunded).toFixed(2)}`);
  }
}

deleteSportsMarkets()
  .then(() => process.exit(0))
  .catch((err) => {
    console.error('Fatal error:', err);
    process.exit(1);
  });
